Cliente: usuario dia a dia. se encuentra en front y se encarga de enviar datos a back a traves de formulario, los cuales son metodos 
de entrada de datos a un SI. Se envian medinte un JSON. 
El JSON es la forma de comunicacion entre distintos sistemas. Se trata de una medida de acceso que permite la comparticion de datos. 
Objetos con propiedades clave-valor.

El cliente se comunica con el servidor mediante peticiones a través del protocolo HTTP mediante el uso de:
GET (Obtener informacion), POST (Crear), PUT (Actualizar), PATCH, DELETE (Borrar).

Endpoint: suma de un verbo y una URL (A donde se envia esa acción).

OBJETIVO: Crear sistema completo CRUM.

GIT: Controlar modificaciones de proyecto y flujo de trabajo. Utiliza Ramas: Principal (donde se encuentra el sistema), rama de 
desarrollo (donde se construye para luego ser enviado al principal) y los de errores (que contienen errores de desarrollo).
Primero se crea el proyecto, se asigna la rama de desarrollo para cada trabajador, se fusionan las ramas y se suben a la principal.
3 estados: Modificado, Staged (si todavía no se ha realizado el commit) y commited.
                        
FRONTEND: Vistas de usuario, de forma intuitiva al sistema, reduciendo carga cognitiva. Consiste en una estructura HTML, CSS que
consiste en la fachada del HTML y el JavaScript que contiene las dinamicas y acciones de la página. 

HTML (index.html):es el lenguaje estándar para crear y estructurar páginas web. Define el contenido y la organización de elementos 
como textos, imágenes, enlaces y formularios mediante etiquetas.

Sintaxis general:
<etiqueta atributo="Valor">Contenido</etiquetaCierre>
Documentacion HTML: developer.mozilla.org/es/docs/Web/HTML

El atributo class="" se puede aplicar a todas las etiquetas. Se utiliza para agrupar elementos que comparten un mismo estilo o 
comportamiento.Varios elementos pueden tener la misma clase.

El atributo id="" se utiliza para identificar un único elemento de forma específica. Solo un elemento puede tener un mismo id 
dentro de una página.

Tablas de especificidad: La especificidad es un sistema de puntos que determina qué regla CSS se aplica cuando hay más de una 
opción válida para un elemento.

10000 | !important
 1000 | Estilos en linea
  100 | #id
   10 | clases/atributos/pseudoclases
    0 | selector universal
   
Semantica de HTML: forma de organizacion de etiquetas. Sirve para no utilizar muchos <div> y que sea mas proligo. 
<header>
<nav> 
<main>
|- <article>
|- <section>
<footer>

Formularios: permite el acceso de datos al sistema. 
Atributos clave: (No se utilizan xq se usa JS)
action: URL/API a la que se envían los datos del formulario cuando se envíe.
method: que tipo de metodo se utiliza. Generalmente es post.

Tipos de input: developer.mozilla.org/es/docs/Web/HTML/Element/input
boton, checkboc, small, gile, image, month, number, range, reset, radio, submit, time, week, etc.

            <input type="text" name="nombre" id="nombre">
    El tipo indica el tipo de atributo que tendrá el campo. El nombre es de uso para el Backend. Se recomienda que el id = name. 

En los input type="checkbox" y "radio" todos los name deben ser iguales en cada campo.
Labels: Cada Label esta asociado a un tipo de input especifico.
<label for="valor_de_name">Campo<label><br>

Validaciones: atributos required (para que sea requerido), minlenght="" maxlenght=""(minima/maxima longitud de caracteres), checked
(para radio, checkbox)

Siempre tener SUBMIT, que es un boton que envía formulario al Backend.  
            <button type="submit">Enviar</button>

CSS: Cascade Style Sheet se usa para estilizar elementos escritos en un lenguaje de marcado como HTML. Funciona con reglas marcadas 
por un selector y compuestas por propiedades. Esto se llama una declaración. 

selector {
    propiedad: valorPropiedad
}
color, text-align,

Se vincula con el HTML en head mediante: 
    <link rel="stylesheet" href="styles.css"></href>

Puede haber selectores por ID, por Clase y se marcan como:

#id {
    propiedad: valorPropiedad
}

.clase {
    propiedad: valorPropiedad
}

BOOTSTRAP: libreria para simplificar la estilizacion de flexbox con CSS. Plantea Web Responsive con un sistema de grillas. 
Un sitio tiene 12 columnas del MISMO ancho cada unam con una serie de filas. Cada seccion es una columna, proponiendo un
grid system. Es un CSS ya escrito de antemano utilizando el atributo class.Para implementar bootstrap en el proyecto:
 
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet" 
    integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>


Documentacion oficial: https://getbootstrap.com/docs/5.3/getting-started/introduction/ 


JavaScript: leguaje que se puede ejecutar en el servidor y el cliente. JS para front para hacer peticiones y mostrar
respuestas y en el back para recibir peticiones y enviar respuestas.
Tipos de datos: undefined, string boolean, null, symbol, number, bigint, obkect (compuesto por claves y valores).

Asignacion de variables: declarar que existen las variables. 
Inicializacion: declarar el valor inicial de la variable.

    const para variables de lectura (nunca se sobreescriben), declaracion de objetos, arrays.
    let para cadenas de caracteres, booleanos, etc (se)

    console.log(variable) = print(variable)

Cadenas de caracteres: se declaran con comillas dobles o simples. Si quiero incluir una variable en la cadena:
    console.log(`Hola mundo, la variable vale: ${x}`)

Operador ternario: <condicion> ? <expresión 1> : <expresion 2>
Operadores: 
    aritmeticos: + (suma), - (resta), * (producto), / (division), % (resto de division entera).
    incre/decremento: ++(aumentar de a 1 la variable), -- (decrementar de a 1 la variable).
    comparación: === (igual estricto), !== (distinto estricto), <, >, <=, >= (mayor, menor).
    lógicos: && (and), || (or), ! (not).
    asignación: = (asigna el valor de la derecha), /=/*=/-=/+= (divide/multiplica/resta/suma el valor de la derecha)

Valores "falsy" ==> 0, false, string vacio, null, undefined, NaN (Not a Number).

Funciones declaradas:
    function suma(a,b) {
        return a + b
    }

Funciones flecha: Funciones simplificadas. Se debe declarar arriba del programa main. 
    const suma = (a, b) => a + b; 


OBJETOS: serie de valores. Toda propiedad es una sociacion entre una clave y un valor.

    const objeto = {
        atributo: "valor",
        atributo2: "valor",
        atributo3: "valor",      
        saludar: function () {
            console.log("Esto es un método con atributo", this.atributo)
        }
    }

"this" hace referencia al objeto en sí. 

objeto.atributo4 = "valor" - Agregar atributo
delete objeto.atributo4 - Borrar atributo

ARRAYS: Se pueden hacer arrays de objetos. 
const objetos = [
    {
        atributo: "valor",
        atributo2: "valor",
        atributo3: "valor", 
    },
    {
        atributo: "valor",
        atributo2: "valor",
        atributo3: "valor", 
    },
];

Iteración: se utilizan mapas para recorrer arreglos. Map recorre el array y por cada elemento hace algo.
    personas.map(persona => console.log(persona));

Filter: recorrer arreglos y crear un arreglo que cumple con la condición dada. 
    const mayores20 = personas.filter(persona => persona.edad > 20);


JSON: objetos clave valor con una notificacion especifica que son datos apropiados para un SI.
Por ejemplo: 
/personas.json

{
  nombre: "Lionel Messi",
  profesion: "Futbolista",
  edad: 37,
  saludar: function() {
    console.log(`Hola, soy ${this.nombre}, un ${this.profesion}. Tengo ${this.edad} años.`);
  }
},
{
  nombre: "Eminem",
  profesion: "Rapero",
  edad: 52,
  saludar: function() {
    console.log(`Hola, soy ${this.nombre}, un ${this.profesion}. Tengo ${this.edad} años.`);
  }
}

Para importar el archivo: import personas from './personas.json' assert { type: 'json' };
                          const personas = require('./personas.json');

BACKEND: maneja la logica de negocio / casos de uso del sistema de forma abstracta. Utiliza peticiones
para comunicarse con la BD y el cliente. Se ejecuta en el entorno node.js que pertmite ejecutar JavaScript
en un servidor. 

npm es el gestor del proyecto. Sirve para crear, ejecutar, subirlo, instalar sw de 3ros del proyecto. 

SQLite: Motor de base de datos.
Sequelize: Framework ORM. Permite vincular el modelo creado con la base de datos. 
Express: Framework de js para construir la API. 
Cors: Permite vincular el backend con el frontend. 

Se instalan por la terminal con: 
    npm install express sequelize sqlite3 cors


package-lock.json => NO TOCAR. Es donde se encuentran dependencias, configuración sensible del proyecto. 

Archivo .gitignore => escribiendo los nombres de los archivos que no se suben a git. 

ASINCRONISMO: Permite ejecutar tareas que toman tiempo (como acceder a una API) sin bloquear el resto del programa.
    Promesas: Son objetos que representan el resultado futuro (éxito o error) de una operación asincrónica.
    Programación asíncronica: simular Sincronismo utilizando funciones asincronicas. 

Path param vs Query param:
En una API REST, los path parameters y query parameters se utilizan para propósitos distintos.

Los path parameters forman parte de la URL y se usan para identificar un recurso específico. 
Por ejemplo, en GET /usuarios/123, el 123 es un path parameter que indica que se quiere acceder
 al usuario con ID 123. Son obligatorios en la estructura de la ruta.

Los query parameters, en cambio, se agregan al final de la URL después del signo de interrogación 
(?) y se usan para filtrar, ordenar o limitar resultados. Por ejemplo: GET /usuarios?rol=admin 
devuelve todos los usuarios cuyo rol es “admin”. Son opcionales y pueden combinarse.

MIDDLEWARE (función que se ejecuta antes o despues de un endpoint que permite translado
de información en distintas partes del código)

CRUD: Create|Read|Update|Delete => Cuatro servicios Basicos (llamados tambien ACID).

Al iniciar el proyecto se debe:
1- En la terminal, desde el directorio de backend, ejecutar:
    C:\Users\user\Proyecto\backend> npm init -y
    Que crea el proyecto node y marca respuestas por defecto. Crea un archivo package.json que tiene datos 
    sobre el proyecto. No es un json ordinario y sirve para gestionar el proyecto. NO SE TOCA!!

2-Definir arquitectura del proyecto:
    Todo se va almacenar en una carpeta source (src) con:
        index.js -> Punto de entrada a la aplicación 
        app.js -> Construir la API (Puente entre front y back)
    Carpeta databases -> donde se almacena todo lo referido a la base de datos del sistema.
    Carpeta tests -> para hacer testing (no se utiliza en este caso).
    Carpeta models -> representacion de tablas de bases de datos a codigo. 
    Carpeta services -> casos de uso, lógica de negocio.
    Carpeta routes -> controladores (donde se construyen los endpoints con las APIs).

PASOS DE RESOLUCIÓN:
----
CONSTRUIR API 
1)- En app.js se debe construir una app express usando cors y express. En app.js debe haber 
la inicializacion de la aplicación, el middleware de cors, routers importados y gestion de errores.
2)- Agregar a package.json: "type":"module", (permitir importar/exportar archivos)
3)- Instalar dependencias de desarrollo: npm i nodemon
        Sirve para mantener el codigo en ejecucion cuando hay cambios en el backend.
        Agregar "dev": "nodemon src/index.js" en la parte de "scripts" de package.json.
        Esto ultimo se utiliza para cuando quiero iniciar el servidor con npm run dev.
        (Sirve para ejecutar/correr proyecto).
4)- Exportar la aplicacion Express para usarla en otros archivos.
5)- En index.js se debe importar la aplicación express. 
6)- Declarar un puerto const PORT = 3000
7)- app.get para mostrar por pantalla que esta corriendo el servidor. 
8)- app.listen para mostrar por terminal que el servidor funciona
9)- BACKEND FUNCIONANDO.
----
BASE DE DATOS
10)- Importar db.sqlite (Base de Datos) a la carpeta del proyeto. 
11)- Crear modelos: crear archivos js de cada tabla que se presenta en la base de datos.
12)- Con Sequelize se crean los modelos:
    -Importar tipos de datos de la base de datos.
    -Declarar objetos: atributos y metodos. 
        -En metodos agregar timestamps: false para que sequealize no registre FechaHora de la operación.
        -En atributos agregar cada tipo de atributos que se encuentre en la bd definiendolos como si fueran
        un objeto. Para ver caracteristicas: sequelize.org/docs/v6
    -Declarar modelo con la union de los objetos 
    -Exportar modelo
----
CADENA DE CONEXIÓN DE BASES DE DATOS
13)- Crear dentro de databases archivo databases.js.
14)- Importar Sequelize y modelos.
15)- Indicar DBMS y ubicación en disco de db.sqlite. 
16)- Definir Modelos utilizando sequelize.define(nombre,atributos,metodos)
    -Por ejemplo: sequelize.define("Tareas", TareasModel.tareasAttributes, TareasModel.tareasMethods)
17)- Crear FKS entre tablas para vincularlas:
    -sequelize.models.Tareas.belongsTo(sequelize.models.Usuarios, {foreignKey: "UsuarioID"})
    La FK indica a que atributo hace referencia a la PK de Usuarios.
18)-Exportar Modelo.
----
SERVICIOS (CASOS DE USO) Y RUTAS
19)- Importar Base de datos definida (archivo databases.js).
20)- Definir servicios.
    -Crear: const entidadServices = {} donde se pondran todos los servicios a utilizar.
    -Añadir Funciones declarando que son asincronicas con async y await permite que la ejecución pare hasta conseguir los datos
        const getAll = async () => { 
        const allUsuarios = await sequelize.models.Usuarios.findAll();
        return allUsuarios.map(usuario => usuario.dataValues)
        }
    -Exportar: export {userServices}
21)- Crear archivo entidad.routes.js en /routes
22)- Importar express y servicios 
23)- Declarar Router para definir endpoints
    router.get("/", async(req, res) => { try {
        const usuarios = await userServices.getAll();
        res.json(usuarios);
    } catch(error) {}}) 
        Donde req y res son el request del cliente y la respuesta del servidor,
        try es intentar realizar algo y catch es lo que haría en caso de error.
    Dentro de try se definen los objetos mediante getAll() y se los parsea a .json
    Dentro de catch se debe devolver una respuesta con el estatus del error.
    Numeros de errores: developer.mozilla.org/es/docs/Web/HTTP/Status
    Se utiliza 500 para los imprevistos. 
    catch (error) {
        res.status(500).json({error: "Error al obtener los usuarios"}) }
24)- Exportar router.
25)- En app.js se importan los endpoints.
    import { usuariosRouter } from "./routes/usuarios.routes";
26)- Definir entrada a endpoints de las entidades 
    app.use("/usuarios", usuariosRouter.router)

VERIFICACIÓN EN POSTMAN
- Ingresar a postman
- Crear HTTP request
- GET http://localhost:3000/usuarios
- Visualizar los datos de los usuarios en la base de datos.

27)- En entidad.routes.js declarar router para crear nuevos datos en la BD. Cuentan con un cuerpo
que es un json.
    router.post("/CrearUsuarios", async(req,res) => {
        try {
            const usuario = await userServices.createUser(req.body);
            res.json(usuario);
        } catch (error) {
            res.status(500).json({error: error.message});
        }
    } )

En caso de que la validacion de Postman no funcione utilizar (desde Powershell):
        Invoke-RestMethod -Uri "http://localhost:3000/usuarios/CrearUsuarios" `
    -Method Post `
    -Body (@{
        nombre = "Lionel"
        apellido = "Messi"
        usuario = "lmessi"
        password = "goat10"
        email = "lionel.messi@mail.com"
    } | ConvertTo-Json) `
    -ContentType "application/json"

28)- Para eliminar por id: 
    const deleteUser = async (idUsuario) => {
        const usuarioABorrar = await sequelize.models.Usuarios.findByPk(idUsuario)
        if (!usuarioABorrar) {
            throw new Error("Usuario no encontrado")
        }
        await sequelize.models.Usuarios.destroy()  
        return { mensaje: "Usuario eliminado correctamente" };
    }

29)- Para buscar por filtro: 
    const getByFilter = async (filtro) => {
        const where = {};

        if (filtro.nombre) {
            where.nombre = { [Op.like]: `%${filtro.nombre}%` };
        }
        if (filtro.apellido) {
            where.apellido = { [Op.like]: `%${filtro.apellido}%` };
        }
        if (filtro.usuario) {
            where.usuario = { [Op.like]: `%${filtro.usuario}%` };
        }
        if (filtro.email) {
            where.email = { [Op.like]: `%${filtro.email}%` };
        }
    }

30)- Para Actualizar: 
        const updateUser = async (idUsuario, body) => {
        const usuario = await sequelize.models.Usuarios.findByPk(idUsuario)
        if (!usuario) {
            throw new Error("Usuario no encontrado")
        }
        usuario.nombre = body.nombre ?? usuario.nombre;
        usuario.apellido = body.apellido ?? usuario.apellido;
        usuario.usuario = body.usuario ?? usuario.usuario;
        usuario.password = body.password ?? usuario.password;
        usuario.email = body.email ?? usuario.email;

        await usuario.save()
        return usuario.dataValues

    }

31)- CRUD BACKEND TERMINADO.
----
FRONTEND CON PETICIONES A BACKEND
VINCULACIÓN FRONT<->BACK
DOM: Document Object Modeler. Etiquetas creadas en HTML. Con Js podemos traer información desde
la API de forma dinamica. Se puede utilizar para animaciones tambien. Un evento es cualquier tipo
de interacción con el sistema. Todos los elementos se manejan a través del document. 
    document.addEventListener(evento, accion_a_realizar_si_ocurre)

Agregar filas a tabla: 
document("DOMContentLoaded", async function() {
    const cuerpoTablea = document.getElementById("cuerpo_tabla");
    cuerpoTabla.innerHTML = ``
    datos.forEach((elemento) => {
        const row = document.createElement('tr'); //filas
        row.innerHTML = `
            <td>${elemento.id}</td>
            <td>${elemento.nombre}</td>
        `
        cuerpoTabla.appendChild(row)
})
})

FETCH: método para traer datos de una API. Sirve para consumir apis en código. Une el cliente
con el servidor. Es Asíncrono por lo que se lo trabaja como promesa o funcionalidad asíncrona. 
Si se unen ambos conceptos (DOM y FETCH), la integración será de JS Puro. Devuelve un archivo
JSON.

Ejemplo de uso:
    const obtenerPokemones = async() => {
        const url= "https://pokeapi.co/api/v2/pokemon"
        const response = await fetch(url)
        const pokemones = await respones.json() // Todos los objetos pokemones 
        console.log(pokemones)
        pokemones.results.map(pokemon => console.log(pokemon.name)) // Extraer los nombres de los pokemones
    } 

La idea del usar DOM y fetch es hacer una tabla de usuarios con datos que se traen de una api de forma dinamica.
Es necesario poder eliminar, editar y crear registros en la tabla. Además de poder buscarlos por algún filtro.

32)- Para poder introducir los registros de la api en la tabla se debe:
    -Crear tabla en html con  un tbody con id:
            <table class="table table-striped table-bordered">
            <thead class="table-dark">
                <tr>
                    <th scope="col">Id</th>
                    <th scope="col">Nombre</th>
                    <th scope="col">Apellido</th>
                    <th scope="col">Usuario</th>
                    <th scope="col">Email</th>
                    <th scope="col">FechaAlta</th>
                    <th>Acciones</th>
                </tr>
            </thead>
            <tbody id="userTable">
            </tbody>    
        </table>
    -En el script.js:
        document.addEventListener("DOMContentLoaded", function () {
            fetchData();
        })

        async function fetchData() {
            try {
                // peticion al endpoint
                const response = await fetch ("http://localhost:3000/usuarios/VerUsuarios");
                // json a array
                const data = await response.json(); 
                // capturar cuerpo de la tabla
                const tbody = document.getElementById("userTable");
                // vaciar tabla de ser necesario
                tbody.innerHTML = "";
                // recorrer el array y se añade la fila a la tabla
                data.forEach(usuario => {
                    const row = document.createElement("tr");
                    row.innerHTML = `
                        <td>${usuario.id}</td>
                        <td>${usuario.nombre}</td>
                        <td>${usuario.apellido}</td>
                        <td>${usuario.usuario}</td>
                        <td>${usuario.email}</td>
                        <td>${usuario.fechaAlta}</td>
                    `;
                // añade la fila a la tabla
                tbody.appendChild(row);
                })
            }
            catch (error) {
                console.error("Error fetching: ", error);
            }}

33)- GetByFilter:
    -En index.html crear un formulario con id="filterForm" y action="". Además de un boton type:"submit"
    
    -En index.js: 
    document.addEventListener("DOMContentLoaded", function () {
    fetchData();

    const form = document.getElementById("filterForm");
    form.addEventListener('submit', async function(event) {
        event.preventDefault(); // Prevenir actualización de la pagina
        
        const nombre = form.nombre.value.trim();
        const apellido = form.apellido.value.trim();
    
        try {
            const response = await fetch(`http://localhost:3000/usuarios/Buscar?nombre=${form.nombre.value}&apellido=${form.apellido.value}`);
            const usuarios = await response.json();
            
            const tbody = document.getElementById("userTable");
            tbody.innerHTML = "";
            if (usuarios.length === 0) {
                message.innerHTML = "<tr><td colspan='6' class='text-center'>No se han encontrado usuarios</td></tr>";
            } else {
            //  sólo los usuarios que coinciden con el filtro (por nombre y/o apellido).
            usuarios.forEach(usuario => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${usuario.id}</td>
                    <td>${usuario.nombre}</td>
                    <td>${usuario.apellido}</td>
                    <td>${usuario.usuario}</td>
                    <td>${usuario.email}</td>
                `;
                tbody.appendChild(row);
            })};
        } catch (error) {
                console.error("Error fetching: ", error);
            }
        });
    });

34)- 
    <!-- Botón para agregar un nuevo usuario -->
    <button type="button" class="btn btn-primary mb-3" id="addUserBtn">Agregar Usuario</button>

    <!-- Formulario para agregar un usuario, oculto inicialmente -->
    <div id="addUserForm" style="display: none;">
        <form id="createUserForm">
            <div class="mb-3">
                <label for="nombre" class="form-label">Nombre</label>
                <input type="text" class="form-control" id="nombre" name="nombre" required>
            </div>
            <div class="mb-3">
                <label for="apellido" class="form-label">Apellido</label>
                <input type="text" class="form-control" id="apellido" name="apellido" required>
            </div>
            <div class="mb-3">
                <label for="usuario" class="form-label">Usuario</label>
                <input type="text" class="form-control" id="usuario" name="usuario" required>
            </div>
            <div class="mb-3">
                <label for="email" class="form-label">Email</label>
                <input type="email" class="form-control" id="email" name="email" required>
            </div>
            <button type="submit" class="btn btn-success">Guardar</button>
            <button type="button" class="btn btn-secondary" id="cancelAddUserBtn">Cancelar</button>
        </form>
    </div>

    document.addEventListener("DOMContentLoaded", function () {
    fetchData();

    // Mostrar formulario para agregar un nuevo usuario
    const addUserBtn = document.getElementById("addUserBtn");
    const addUserForm = document.getElementById("addUserForm");
    const cancelAddUserBtn = document.getElementById("cancelAddUserBtn");

    addUserBtn.addEventListener("click", function() {
        addUserForm.style.display = "block";
    });

    cancelAddUserBtn.addEventListener("click", function() {
        addUserForm.style.display = "none";
    });

    const createUserForm = document.getElementById("createUserForm");
    createUserForm.addEventListener("submit", async function(event) {
        event.preventDefault();

        const nombre = createUserForm.nombre.value;
        const apellido = createUserForm.apellido.value;
        const usuario = createUserForm.usuario.value;
        const email = createUserForm.email.value;

        try {
            const response = await fetch("http://localhost:3000/usuarios/crearUsuarios", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ nombre, apellido, usuario, email })
            });

            if (response.ok) {
                alert("Usuario agregado exitosamente");
                addUserForm.style.display = "none";
                fetchData(); // Refrescar la lista de usuarios
            } else {
                alert("Error al agregar el usuario");
            }
        } catch (error) {
            console.error("Error al agregar usuario: ", error);
        }
    });

    const form = document.getElementById("filterForm");
    form.addEventListener('submit', async function(event) {
        event.preventDefault(); // Prevenir actualización de la página
        
        const nombre = form.nombre.value.trim();
        const apellido = form.apellido.value.trim();
    
        try {
            const response = await fetch(`http://localhost:3000/usuarios/Buscar?nombre=${nombre}&apellido=${apellido}`);
            const usuarios = await response.json();
            
            const tbody = document.getElementById("userTable");
            tbody.innerHTML = "";

            usuarios.forEach(usuario => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${usuario.id}</td>
                    <td>${usuario.nombre}</td>
                    <td>${usuario.apellido}</td>
                    <td>${usuario.usuario}</td>
                    <td>${usuario.email}</td>
                    <td>
                        <button class="btn btn-warning editBtn" data-id="${usuario.id}">Editar</button>
                        <button class="btn btn-danger deleteBtn" data-id="${usuario.id}">Eliminar</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            addEventListenersToButtons();
        } catch (error) {
            console.error("Error fetching: ", error);
        }
    });
});

async function fetchData() {
    try {
        const response = await fetch("http://localhost:3000/usuarios/verUsuarios");
        const data = await response.json();

        const tbody = document.getElementById("userTable");
        tbody.innerHTML = "";

        data.forEach(usuario => {
            const row = document.createElement("tr");
            row.innerHTML = `
                <td>${usuario.id}</td>
                <td>${usuario.nombre}</td>
                <td>${usuario.apellido}</td>
                <td>${usuario.usuario}</td>
                <td>${usuario.email}</td>
                <td>
                    <button class="btn btn-warning editBtn" data-id="${usuario.id}">Editar</button>
                    <button class="btn btn-danger deleteBtn" data-id="${usuario.id}">Eliminar</button>
                </td>
            `;
            tbody.appendChild(row);
        });

        addEventListenersToButtons();
    } catch (error) {
        console.error("Error fetching: ", error);
    }
}

function addEventListenersToButtons() {
    document.querySelectorAll(".editBtn").forEach(button => {
        button.addEventListener("click", async function() {
            const userId = this.getAttribute("data-id");

            try {
                const response = await fetch(`http://localhost:3000/usuarios/obtenerById/${userId}`);
                const usuario = await response.json();

                document.getElementById("nombre").value = usuario.nombre;
                document.getElementById("apellido").value = usuario.apellido;
                document.getElementById("usuario").value = usuario.usuario;
                document.getElementById("email").value = usuario.email;

                addUserForm.style.display = "block";

                const createUserForm = document.getElementById("createUserForm");
                createUserForm.addEventListener("submit", async function(event) {
                    event.preventDefault();

                    const nombre = createUserForm.nombre.value;
                    const apellido = createUserForm.apellido.value;
                    const usuario = createUserForm.usuario.value;
                    const email = createUserForm.email.value;

                    const updateResponse = await fetch(`http://localhost:3000/usuarios/actualizarUsuario/${userId}`, {
                        method: "PUT",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ nombre, apellido, usuario, email })
                    });

                    if (updateResponse.ok) {
                        alert("Usuario actualizado");
                        addUserForm.style.display = "none";
                        fetchData(); // Refrescar la lista de usuarios
                    } else {
                        alert("Error al actualizar el usuario");
                    }
                });
            } catch (error) {
                console.error("Error al editar usuario: ", error);
            }
        });
    });

        document.querySelectorAll(".deleteBtn").forEach(button => {
            button.addEventListener("click", async function() {
                const userId = this.getAttribute("data-id");

                try {
                    const response = await fetch(`http://localhost:3000/usuarios/eliminarUsuario/${userId}`, {
                        method: "DELETE"
                    });

                    if (response.ok) {
                        alert("Usuario eliminado exitosamente");
                        fetchData(); // Refrescar la lista de usuarios
                    } else {
                        alert("Error al eliminar el usuario");
                    }
                } catch (error) {
                    console.error("Error al eliminar usuario: ", error);
                }
            });
        });
}



