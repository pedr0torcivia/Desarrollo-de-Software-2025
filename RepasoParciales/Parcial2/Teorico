Â¿CÃ³mo harÃ­as para que TicketForm tambiÃ©n pueda editar un ticket ademÃ¡s de crearlo? Â¿CÃ³mo distinguirÃ­as entre ambas acciones?
UsarÃ­a el mismo componente TicketForm para ambas acciones. Si recibe un ticket por props, significa que es una modificaciÃ³n y se inicializa el formulario con esos datos. Si no recibe nada, se asume que es una alta. La diferencia se implementa chequeando si existe ticket.idTicket: si sÃ­, se hace un PUT; si no, un POST.

Â¿QuÃ© ventajas ofrece React con JSX en comparaciÃ³n con manipular el DOM directamente con JavaScript puro?
JSX permite escribir HTML dentro de JavaScript de forma declarativa, haciendo el cÃ³digo mÃ¡s legible y estructurado. Evita manipulaciÃ³n directa del DOM, lo cual reduce errores, mejora el rendimiento y facilita el mantenimiento.

Â¿QuÃ© funciÃ³n cumple el useEffect en el componente TicketList? Â¿Por quÃ© lo usamos ahÃ­ y no en App.js directamente?
useEffect permite ejecutar una acciÃ³n al montar el componente, como hacer una peticiÃ³n a la API. Se usa en TicketList si la lÃ³gica de carga estÃ¡ encapsulada ahÃ­. Pero si el estado estÃ¡ en App.js, conviene usar useEffect en App para mantener el control centralizado.

Â¿QuÃ© ventajas tiene separar las llamadas Axios en archivos de servicios y no hacerlas directamente en los componentes?
Centraliza la lÃ³gica de acceso a la API, facilita la reutilizaciÃ³n, mejora la mantenibilidad y permite testear mÃ¡s fÃ¡cilmente los servicios sin tocar la UI.

Â¿QuÃ© ventaja tiene tener un Ãºnico estado global en App.js y pasar datos por props en lugar de que cada componente tenga su propio estado?
Permite mantener sincronizada toda la aplicaciÃ³n. Si varios componentes necesitan ver o modificar los mismos datos (como los tickets), es mejor centralizarlo en App para evitar inconsistencias y duplicaciÃ³n de lÃ³gica.

Â¿CÃ³mo garantizarÃ­as que no se envÃ­en formularios con datos invÃ¡lidos desde TicketForm? Â¿DÃ³nde validarÃ­as: en frontend, backend o ambos?
ValidarÃ­a en ambos. En el frontend uso required, validaciones con react-hook-form o funciones personalizadas. En el backend valido antes de guardar con condiciones o reglas de Sequelize. AsÃ­ se cubren errores del usuario y posibles manipulaciones maliciosas.

Â¿Por quÃ© usamos una SPA (Single Page Application) en vez de una pÃ¡gina tradicional que recarga cada vez?
Porque la SPA mejora la experiencia del usuario: la pÃ¡gina no se recarga, los cambios son instantÃ¡neos, se navega mÃ¡s rÃ¡pido y consume menos datos al evitar recargar archivos repetidamente.

Â¿QuÃ© pasa si no usamos cors() en el backend cuando trabajamos con frontend y backend separados?
El navegador bloquea las peticiones por polÃ­tica de seguridad, ya que impide el intercambio de recursos entre orÃ­genes distintos. cors() permite explÃ­citamente esas conexiones.

Â¿Por quÃ© usamos .catch() en Axios? Â¿QuÃ© pasa si no lo usamos?
.catch() permite capturar errores como fallas de red o errores del backend. Si no lo usamos, los errores quedan sin manejar y la app puede romperse o mostrar mal funcionamiento sin avisar al usuario.

Â¿QuÃ© diferencia hay entre usar axios.get('/api/tickets') directamente en App.js y encapsularlo en una funciÃ³n getAllTickets() en un archivo tickets.service.js?
Encapsularlo permite reutilizar esa funciÃ³n en otros componentes, simplifica el cÃ³digo del componente, mejora la organizaciÃ³n y facilita testear o cambiar la URL desde un solo lugar.

Â¿QuÃ© estrategia podrÃ­as usar si el backend tarda mucho en responder? Â¿CÃ³mo mejorarÃ­as la experiencia del usuario mientras espera?
Mostrar un spinner o mensaje de â€œCargando...â€ mientras se hace la peticiÃ³n. TambiÃ©n puedo usar setTimeout para alertas si tarda demasiado o habilitar el reintento automÃ¡tico.

Â¿QuÃ© implicarÃ­a agregar paginaciÃ³n en el frontend si el backend devolviera 1000 tickets?
EvitarÃ­a cargar todos los tickets de una sola vez. El frontend mandarÃ­a consultas con ?page=1&limit=20, y mostrarÃ­a solo esos 20 por pÃ¡gina. TambiÃ©n requiere botones de navegaciÃ³n.

Â¿CÃ³mo harÃ­as para mostrar un mensaje de â€œGuardado exitosoâ€ o â€œError al guardarâ€ despuÃ©s de enviar el formulario?
UsarÃ­a .then() y .catch() de Axios. En .then() muestro un mensaje tipo alert o actualizo un estado mensaje. En .catch() capturo el error y muestro otro mensaje con el error correspondiente.

Â¿Por quÃ© conviene tener TicketList y TicketForm como componentes separados y no hacer todo en App.js?
Se aplica separaciÃ³n de responsabilidades. TicketList se ocupa de mostrar datos; TicketForm, de cargarlos. Esto hace el cÃ³digo mÃ¡s modular, reutilizable y fÃ¡cil de mantener.

Â¿QuÃ© ocurre si se borra el archivo donde estÃ¡ definido el modelo Sequelize en el backend? Â¿QuÃ© impacto tendrÃ­a?
No se podrÃ­an crear, consultar ni modificar los datos de esa entidad. Las rutas que dependen del modelo lanzarÃ­an errores y el backend no iniciarÃ­a correctamente si se usa sequelize.sync().

Â¿QuÃ© significa que React tenga un â€œDOM virtualâ€? Â¿QuÃ© ventajas trae respecto al DOM real?
React usa un DOM virtual para comparar cambios en memoria antes de aplicarlos al DOM real. Esto hace que las actualizaciones sean mÃ¡s rÃ¡pidas y eficientes, ya que solo modifica lo que cambiÃ³.

Â¿Por quÃ© usamos value={campo} y onChange={...} en los inputs de un formulario controlado? Â¿QuÃ© pasa si no lo hacemos?
Porque en un formulario controlado React maneja el valor del input. value lo vincula al estado, y onChange actualiza ese estado. Si no lo hacemos, el input se vuelve no controlado y puede generar comportamientos inconsistentes.

Â¿QuÃ© rol cumple react-hook-form en la gestiÃ³n de formularios? Â¿En quÃ© simplifica la lÃ³gica respecto a useState tradicional?
react-hook-form maneja el estado y la validaciÃ³n del formulario automÃ¡ticamente. Evita definir mÃºltiples useState, mejora el rendimiento, reduce cÃ³digo repetido y facilita validar mÃºltiples campos.

Â¿QuÃ© es un Hook en React y por quÃ© son preferidos frente a componentes de clase?
Un Hook es una funciÃ³n especial de React para usar estado y efectos. Son preferidos porque simplifican el cÃ³digo, evitan boilerplate, permiten reusar lÃ³gica entre componentes y se integran bien con funciones modernas.

Â¿Por quÃ© usamos useState([]) en el listado? Â¿QuÃ© representa ese arreglo vacÃ­o al principio?
Inicializa el estado de la lista vacÃ­a mientras esperamos los datos. Representa que aÃºn no hay tickets cargados y previene errores al intentar mapear undefined o null.
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
            Â¿CÃ³mo estructurarÃ­as la comunicaciÃ³n desde TicketList hacia App.js si fuera necesario modificar un ticket?
            CrearÃ­a una funciÃ³n en App.js llamada handleEdit(ticket) que reciba como parÃ¡metro el objeto ticket a modificar. Esta funciÃ³n se pasarÃ­a como prop al componente TicketList bajo el nombre onEdit. Dentro de TicketList, en cada fila de la tabla, agregarÃ­as un botÃ³n "Editar" que, al hacer clic, dispare esa funciÃ³n onEdit(ticket). De esta manera, se comunica el componente hijo con el padre. AdemÃ¡s, se debe agregar una columna en el encabezado de la tabla llamada "AcciÃ³n" o "Editar" para mantener la estructura clara.

            Â¿Por quÃ© elegimos usar react-hook-form en lugar de formularios controlados tradicionales con useState? Â¿QuÃ© ventajas ofrece?
            react-hook-form simplifica la gestiÃ³n de formularios evitando el uso repetitivo de useState para cada campo. Solo se necesita el hook useForm, lo cual reduce el cÃ³digo y mejora el rendimiento. TambiÃ©n ofrece validaciÃ³n integrada de campos, manejo automÃ¡tico del evento submit, control del estado del formulario (por ejemplo, si fue modificado o enviado), y facilita el acceso a errores. En resumen, hace que crear, validar y enviar formularios sea mÃ¡s eficiente y limpio.

            Â¿CÃ³mo manejarÃ­as un error si la peticiÃ³n POST falla (por ejemplo, el servidor no responde o hay un error de validaciÃ³n)?
            CapturarÃ­a el error con .catch() en la promesa de Axios, luego setearÃ­a un estado de error y mostrarÃ­a un mensaje al usuario, por ejemplo, con un alert, modal o una etiqueta span. Si es un error de validaciÃ³n, puedo mostrar el mensaje especÃ­fico del backend. Si es un error del servidor o red, mostrarÃ­a un mensaje genÃ©rico como "Intente mÃ¡s tarde", para no revelar detalles tÃ©cnicos al usuario.

            Â¿Por quÃ© es importante que App.js sea quien actualice el estado de los tickets, y no TicketForm directamente?
            Porque la lista de tickets es compartida entre varios componentes, como TicketList. Centralizar el estado en App.js permite que todos los componentes que lo necesiten lo reciban vÃ­a props. Si TicketForm manejara el estado, se romperÃ­a esa comunicaciÃ³n y habrÃ­a que pasar callbacks innecesarios hacia arriba. TicketForm debe enfocarse solo en capturar y enviar los datos del formulario.

            Â¿Por quÃ© se decidiÃ³ modularizar la aplicaciÃ³n en componentes como App.js, TicketList.jsx y TicketForm.jsx? Â¿QuÃ© beneficios tiene?
            La modularizaciÃ³n mejora la organizaciÃ³n del cÃ³digo, haciÃ©ndolo mÃ¡s legible, mantenible y reutilizable. Cada componente tiene una responsabilidad clara: App.js maneja el estado general, TicketList muestra los datos, y TicketForm gestiona la entrada del usuario. Esto permite renderizar de forma condicional, facilita pruebas unitarias y mantiene la cohesiÃ³n funcional dentro de cada mÃ³dulo.
-----
1. Por quÃ© se utiliza JWT actualmente?
Porque es un estÃ¡ndar moderno, liviano y seguro que permite autenticar usuarios sin mantener sesiones en el servidor. El JWT estÃ¡ firmado y contiene toda la informaciÃ³n necesaria del usuario, lo que permite validarlo localmente sin consultar la base de datos. Es especialmente Ãºtil en arquitecturas modernas como APIs REST y aplicaciones frontend como React, donde se necesita escalabilidad y velocidad.

2. Â¿QuÃ© es un IdP (Identity Provider) y cuÃ¡l es su funciÃ³n?
Es un software encargado de autenticar identidades. Cuando un usuario inicia sesiÃ³n, el IdP valida sus credenciales y, si son correctas, emite un token (por ejemplo, un JWT). Este token se utiliza luego para acceder a los sistemas protegidos. AdemÃ¡s, el IdP puede incluir informaciÃ³n como roles, permisos y tiempo de expiraciÃ³n dentro del token.

3. Â¿QuÃ© diferencia hay entre un token de usuario y un token de administrador?
Ambos son tokens de acceso (generalmente JWT), pero representan diferentes niveles de permiso.
El token de usuario representa a un usuario estÃ¡ndar e incluye su identidad bÃ¡sica.
El token de administrador incluye informaciÃ³n adicional, como roles o permisos elevados.
La diferencia radica en los claims dentro del token, como un campo role: admin o scope: write.

4. Si quisieras agregar la actualizaciÃ³n de una actividad desde un componente hijo, Â¿cÃ³mo lo harÃ­as hacia App.jsx?
CrearÃ­a una funciÃ³n en App.jsx (por ejemplo, handleEditarActividad) y la pasarÃ­a como prop al componente hijo correspondiente. Desde el hijo, al hacer clic en "Editar", se llamarÃ­a a esa funciÃ³n enviando el ID o el objeto completo de la actividad. En App.jsx, se guardarÃ­a esa actividad en un estado (actividadSeleccionada) y se enviarÃ­a como prop al formulario, permitiendo editarla.

5. Â¿Por quÃ© App.jsx debe manejar los estados?
Porque es el componente padre y centraliza la lÃ³gica de la aplicaciÃ³n. Al tener el estado global, puede pasarlo a los componentes hijos y recibir actualizaciones desde ellos mediante callbacks. Si cada componente tuviera su propio estado, serÃ­a difÃ­cil mantener la sincronizaciÃ³n entre ellos.

6. Â¿Por quÃ© App.jsx debe manejar el estado y no TicketForm directamente?
Porque TicketForm solo debe encargarse de mostrar y procesar el formulario. La lista de tickets, su actualizaciÃ³n y almacenamiento deben ser responsabilidad de App.jsx, que gestiona el estado global y permite que los cambios se reflejen tambiÃ©n en TicketList.

7. Si TicketList necesitara modificar un ticket, Â¿cÃ³mo estructurarÃ­as esa comunicaciÃ³n de vuelta hacia App.js?
Dentro de TicketList, capturarÃ­a el evento de clic en "Editar" y llamarÃ­a a una funciÃ³n pasada por props desde App.jsx (por ejemplo, onEdit). Esa funciÃ³n se encarga de buscar el ticket por ID, guardarlo en un estado (ticketSeleccionado) y pasarlo al formulario. AsÃ­ se completa el flujo de ediciÃ³n desde el hijo hacia el padre.

8. Â¿Por quÃ© elegimos usar react-hook-form en lugar de manejar formularios controlados tradicionales de React? Â¿QuÃ© ventajas ofrece?
Porque permite registrar inputs sin necesidad de usar useState para cada campo. Simplifica el cÃ³digo, mejora el rendimiento (menos renders) y facilita la validaciÃ³n. AdemÃ¡s, provee herramientas como handleSubmit, errors y formState que permiten controlar fÃ¡cilmente el estado y la validez del formulario.

9. Â¿CÃ³mo manejarÃ­as un error si la peticiÃ³n POST falla (por ejemplo, el servidor no responde o hay un problema de validaciÃ³n en el backend)?
UsarÃ­a un bloque try/catch o .catch() en la llamada con Axios. Si ocurre un error, capturarÃ­a el mensaje y lo mostrarÃ­a al usuario, ya sea mediante un alert, un mensaje en pantalla o una etiqueta. Si es un error de validaciÃ³n, podrÃ­a mostrar mensajes especÃ­ficos por campo. Si es un error del servidor o red, mostrarÃ­a un mensaje general como "Intente nuevamente mÃ¡s tarde".

10. Describe paso a paso quÃ© ocurre en backend/index.js desde que el servidor Express recibe una peticiÃ³n GET a /api/tareas hasta que envÃ­a la respuesta al cliente. Â¿QuÃ© middlewares de Express intervienen y cuÃ¡l es su funciÃ³n?
Primero, la peticiÃ³n entra al servidor. Pasa por cors() que habilita el acceso desde el frontend, y por express.json() que permite interpretar cuerpos JSON. Luego se enruta a /api/tareas mediante el router, que ejecuta la funciÃ³n correspondiente (por ejemplo, findAll() en el servicio), la cual usa Sequelize para consultar la base de datos. Finalmente, la respuesta se devuelve al cliente con res.json().

11. Si quisieras aÃ±adir un filtro opcional a la ruta /api/tareas para buscar tambiÃ©n por Responsable, Â¿cÃ³mo modificarÃ­as la lÃ³gica?
En el endpoint /api/tareas, capturarÃ­a req.query.search y req.query.responsable. Luego, construirÃ­a un objeto where dinÃ¡mico usando Op.like de Sequelize para aplicar filtros condicionales si esos parÃ¡metros estÃ¡n presentes. AsÃ­, se puede buscar por descripciÃ³n, por responsable o por ambos combinados.

12. Â¿CÃ³mo interactÃºa la funciÃ³n de carga inicial de tareas en scripts/scripts.js con el DOM?
Utiliza document.getElementById() para seleccionar el contenedor <tbody>. Luego, itera sobre la lista de tareas usando forEach() y genera dinÃ¡micamente elementos <tr> y <td> para cada campo (id, descripciÃ³n, responsable). Estas filas se agregan a la tabla usando appendChild().

13. Â¿CÃ³mo se maneja la bÃºsqueda en el frontend clÃ¡sico al hacer clic en "Buscar"?
Se captura el valor del input con document.getElementById('inputBuscar').value, se construye la URL con query string usando encodeURIComponent, y se hace el fetch. Antes de mostrar los resultados nuevos, se limpia la tabla con tabla.innerHTML = '', y luego se insertan las filas correspondientes a los datos devueltos.

14. Â¿CÃ³mo mostrarÃ­as el mensaje "No se encontraron tareas" si una bÃºsqueda no devuelve resultados? Â¿DÃ³nde lo implementarÃ­as?
Lo implementarÃ­a en el frontend. Si el array de tareas devuelto estÃ¡ vacÃ­o (tareas.length === 0), en lugar de mostrar una tabla vacÃ­a, insertarÃ­a un mensaje en pantalla que diga "No se encontraron tareas". Esto mejora la experiencia del usuario, ya que indica claramente que no hubo coincidencias.

Archivo	QuÃ© se hace
keycloak.js	Inicializa Keycloak
index.js	Envuelve la app con el proveedor de autenticaciÃ³n
App.jsx	Define las rutas y cuÃ¡les son protegidas
ProtectedRoute.jsx	Verifica si el usuario estÃ¡ logueado y tiene rol
api.js	Configura Axios para que mande el token
Productos.jsx	Muestra datos protegidos desde el backend
________________________________________
Â¿CÃ³mo funciona todo junto?
1.	El usuario entra a React â†’ no estÃ¡ logueado â†’ Keycloak lo redirige al login.
2.	Al loguearse, Keycloak entrega el JWT.
3.	React guarda ese token y lo usa con Axios en cada request.
4.	Al entrar a /productos, React verifica con ProtectedRoute que el usuario tenga el rol requerido.
5.	Si todo estÃ¡ bien, se cargan los productos desde el backend.


ğŸ”‘ El IDP (como Keycloak):
âœ… Crea y firma el token JWT cuando el usuario se loguea.

âŒ No valida el token en cada request.

ğŸ–¥ï¸ El backend (tu API en Express, por ejemplo):
âœ… Recibe el JWT en cada request (en el header Authorization).

âœ… Verifica que:
El token no estÃ© vencido
La firma sea vÃ¡lida
El rol del usuario sea el correcto (admin, lector, etc.)
Y si todo estÃ¡ bien... le deja pasar. Si no, devuelve un 401 o 403.

ğŸ“Œ ComparaciÃ³n clara:
Rol	Â¿QuÃ© hace?
IDP (Keycloak)	Autentica al usuario y le entrega un JWT
Backend (API)	Verifica que ese JWT sea vÃ¡lido y decide si da acceso

ğŸ§  AnalogÃ­a:
El IDP es como la oficina que emite tu credencial.
El backend es el guardia que te pide esa credencial para dejarte pasar o no.


PREGUNTAS Y RESPUESTAS SOBRE CAMBIOS EN EL CÃ“DIGO (MODELO CRUD)
==============================================================

1. Â¿QuÃ© pasa si agrego una nueva columna al modelo Sequelize?
--------------------------------------------------------------
Tu modelo Sequelize actual estÃ¡ en backend/src/models/Usuarios.js. El objeto usuariosAttributes define los campos. Si querÃ©s agregar una columna nueva:

1. SumÃ¡s una propiedad mÃ¡s en ese objeto, por ejemplo:
   edad: {
     type: DataTypes.INTEGER,
     allowNull: true
   }

2. Si tu sync() estÃ¡ configurado como sequelize.sync({ alter: true }), la tabla se actualiza automÃ¡ticamente.

3. AdemÃ¡s deberÃ­as:
   - Agregar el nuevo campo en los formularios (PostForm.jsx, PutForm.jsx).
   - Modificar el backend para aceptar ese campo (en los servicios y routers).
   - Agregarlo al servicio en el frontend (usuarios.service.js).


2. Â¿CÃ³mo se agrega una columna calculada (por ej. "total")?
-------------------------------------------------------------
No estÃ¡ en la base de datos. Lo podÃ©s:
- Calcular en el backend antes de mandar la respuesta (en usuarios.service.js).
- O hacer el cÃ¡lculo en el frontend en el componente Tabla.jsx antes de mostrarla.


3. Â¿CÃ³mo se muestra una columna adicional en la tabla del frontend?
--------------------------------------------------------------------
EstÃ¡ en frontend/src/components/Tabla.jsx. AgregÃ¡s:

1. Un nuevo <th>NombreColumna</th> en el <thead>.
2. Y en cada <tr>, otra celda con {row.nombreColumna} en el <tbody>.


4. Â¿QuÃ© hay que tocar para ordenar los resultados por un campo (por ejemplo fecha)?
-----------------------------------------------------------------------------------
En tu backend podÃ©s modificar findAll() en usuarios.service.js con:
  findAll({ order: [['fechaAlta', 'DESC']] });

TambiÃ©n podrÃ­as ordenar en el frontend usando .sort() si los datos ya se cargaron todos.


5. Â¿CÃ³mo agrego un filtro por fecha o campo adicional?
-------------------------------------------------------
1. En el backend (usuarios.routes.js), capturÃ¡s el filtro con req.query y usÃ¡s where:
   where: {
     fechaAlta: {
       [Op.gte]: fechaInicio
     }
   }

2. En el frontend (Filtro.jsx y usuarios.service.js), agregÃ¡s un nuevo campo en el formulario que mande ese filtro en la URL.


6. Â¿QuÃ© implica cambiar de SQLite a PostgreSQL?
-----------------------------------------------
En databases.js (src/databases/databases.js):

- CambiÃ¡s de:
  new Sequelize({ dialect: 'sqlite', storage: 'db.sqlite' })
  a:
  new Sequelize('mi_db', 'usuario', 'pass', {
    host: 'localhost',
    dialect: 'postgres'
  });

- InstalÃ¡s pg y pg-hstore.


7. Â¿CÃ³mo se integran validaciones del lado backend?
----------------------------------------------------
Ya usÃ¡s Sequelize. TenÃ©s cosas como:
  unique: true,
  allowNull: false

TambiÃ©n podrÃ­as validar manualmente en el router o servicio:
  if (!req.body.usuario) return res.status(400).json({ error: "Usuario obligatorio" });


8. Â¿CÃ³mo se agrega una relaciÃ³n entre modelos?
----------------------------------------------
Tu proyecto tiene un solo modelo, pero si tuvieras, dirÃ­as:
  Reserva.belongsTo(Cliente);
  Cliente.hasMany(Reserva);

Y luego en la consulta:
  Reserva.findAll({ include: Cliente });


9. Â¿CÃ³mo agrego paginaciÃ³n al backend y frontend?
--------------------------------------------------
En usuarios.service.js:
  const { count, rows } = await Usuario.findAndCountAll({ limit, offset });

Y en el frontend (ConsultasUsuarios.jsx), agregÃ¡s botones para cambiar pÃ¡gina y mandÃ¡s ?limit=10&offset=20.


10. Â¿CÃ³mo agrego una columna solo visible para usuarios admin?
---------------------------------------------------------------
En el backend, verificÃ¡s el rol del usuario con el token:
  if (req.user.role === 'admin') {
    usuario.adminInfo = ...;
  }

En el frontend:
  {usuario.role === 'admin' && <td>{row.infoPrivada}</td>}


11. Â¿CÃ³mo agrego una columna de otra tabla (join)?
---------------------------------------------------
En Sequelize:
  Usuario.findAll({ include: Perfil });

Y accedÃ©s en frontend con: row.perfil.nombre


12. Â¿CÃ³mo testeo que se agregÃ³ bien una funcionalidad?
-------------------------------------------------------
UsÃ¡s Jest + Supertest. Por ejemplo:
  test('crea usuario', async () => {
    const res = await request(app).post('/usuarios').send({ nombre: 'Juan' });
    expect(res.statusCode).toBe(201);
  });


13. Â¿CÃ³mo manejo errores del backend en el frontend?
-----------------------------------------------------
En usuarios.service.js:
  .catch((error) => {
    if (error.response.status === 400) {
      alert("Faltan datos");
    }
  });


14. Â¿CÃ³mo agrego mensajes de Ã©xito o feedback?
-----------------------------------------------
En el then() de Axios:
  .then(() => {
    setMensaje("Guardado correctamente");
    alert("Guardado");
  });


15. Â¿CÃ³mo reutilizo un formulario para Alta y ModificaciÃ³n?
------------------------------------------------------------
Tu PutForm.jsx y PostForm.jsx podrÃ­an unirse. ControlÃ¡s si hay id:
  if (id) {
    // PUT
  } else {
    // POST
  }


16. Â¿CÃ³mo agrego un campo obligatorio en el frontend?
------------------------------------------------------
Ya usÃ¡s react-hook-form. TenÃ©s esto en tus formularios:
  <input {...register("nombre", { required: "Nombre requerido" })} />


17. Â¿CÃ³mo agrego confirmaciÃ³n antes de eliminar?
-------------------------------------------------
En Tabla.jsx, antes del handleDeleteUser(id):
  if (window.confirm("Â¿Seguro que querÃ©s eliminar?")) {
    handleDeleteUser(id);
  }


18. Â¿CÃ³mo se visualizan y actualizan los estados de React en formulario controlado?
-------------------------------------------------------------------------------------
Con useState:
  const [nombre, setNombre] = useState("");
  <input value={nombre} onChange={(e) => setNombre(e.target.value)} />


19. Â¿Diferencia entre onChange y onInput?
------------------------------------------
- onChange: al confirmar (o perder foco).
- onInput: cada tecla. En formularios controlados se prefiere onChange.


20. Â¿CÃ³mo vinculo input al estado?
-----------------------------------
  const [email, setEmail] = useState("");
  <input value={email} onChange={e => setEmail(e.target.value)} />


21. Â¿CÃ³mo limitar nÃºmero mÃ¡ximo?
---------------------------------
  <input type="number" max={100} />
  // o validaciÃ³n manual
  if (e.target.value <= 100) setEdad(e.target.value);


22. Â¿CÃ³mo validar fecha?
-------------------------
Con:
  <input type="date" />
o regex si querÃ©s controlar el formato vos: /^\d{4}-\d{2}-\d{2}$/


23. Â¿CÃ³mo marcar errores visualmente?
--------------------------------------
Con Bootstrap:
  <input className={`form-control ${errors.campo && "is-invalid"}`} />
  <div className="invalid-feedback">Campo requerido</div>


24. Â¿CÃ³mo limpiar estados despuÃ©s de guardar?
----------------------------------------------
DespuÃ©s del axios.post(...), hacÃ©s:
  setNombre("");
  setApellido("");
o reiniciÃ¡s todo con reset() si usÃ¡s react-hook-form.
