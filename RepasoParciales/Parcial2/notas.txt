REACT: framework/libreria de JS para construir GUI. Su finalidad es construir la parte del cliente.Es de utilidad para no tener 1 HTML 
por pantalla, por lo que se busca reutilizar codigo de un archivo para mejorar mantenibilidad, costos, etc. Es DECLARATIVO. Esto significa
que no se trata de un programa secuencial/iterativa. El paradigma de react es hacer todo con JS (no se utiliza HTML), utilizando una sintaxis
HTML EN JS llamada JSX (JS y XML).Todo en react, es un componente (estilo y logica residen en el), los cuales son piezas de codigo logicas y
autocontenidas que describen parte de la GUI. Estos se pueden juntar para crear una GUI completa y React abstrae la mayor parte del trabajo 
de renderizado, permitiendo llevar un enfoque orientado al diseño de interfaz.

Utilizar dos terminales: una para back y otra para front.
Para creacion del proyecto: npx create-react-app frontend
NPX es un subconjunto de NPM

Extensiones de react:
+ ES7+ React/Redux/React-Native
+ Path Intellisense
+ Reactjs code snippets
+ SQLite Viewer

El comando creo diferentes carpetas con archivos:
-public: archivos estaticos (fotos, videos, audios, etc.), manifest y tobots se usan para subir a internet
    index.HTML -> Tiene un solo div que no se debe tocar. Es leido por index.js de src.
        <div id="root"></div> Esto es importante ya que alli se va a crear la aplicación
-src:
    App.JS -> contiene JSX que permite escribir codigo similar a HTML con JS. Es donde se encuentra la interfaz.
    Definición del componente principal o inicial de React que representa una parte de nuestra aplicación
    index.js -> Indica que se debe crear una aplicación react con en el HTML. Inicia la ejecución de la librería de React y del componente App, 
    es el que va a capturar el elemento que esta ubicado en nuestro index.html
            const root = ReactDOM.createRoot(document.getElementById('root'));
        Luego indica que dentro de esa aplicacion indica que debe mostrarse todo lo que esté en App.JS
            root.render(
                <React.StrictMode>
                    <App />
                </React.StrictMode>
                );

En simples palabras: index.html es leido por index.js, index.js indica que se muestre el contenido de App.js y su contenido se va a convertir
en HTML en index.html.  
TODO LO QUE ESCRIBAMOS VA A SER CODIGO JAVASCRIPT QUE MEDIANTE UN PROCESO QUE CONVIERTE EN HTML PARA QUE PUEDA SER MOSTRADO AL USUARIO. 

Para correr el archivo del front:
    npm run start

COMPONENTE: pieza de codigo que se pueden reutilizar en distintos proyectos. REACT es orientado a componentes. Pueden ser botones, pantallas, 
formularios, etc. Son reutilizables. Nunca puedo devolver multiples interfaces en un componente. 
RENDERIZACIÓN: proceso en el que el JS se trasforma en HTML. proceso en el que los componentes de React se convierten enelementos del DOM 
(Document Object Model) que se pueden mostrar en el navegador. Cada componente es independiente entre sí.

Cuando se crea un componente en React, se define su estructura y comportamiento através de código JavaScript. Luego, cuando se renderiza el 
componente, React toma esa estructura y la convierte en elementos del DOM que se muestran en la pantalla.

App.js contiene la aplicacion react que es un arbol genealogico de componentes. Es decir que importa los que se encuentra en cada componente 
y lo muestra mediante index.js en index.html. La funcion App() es la funcion padre de todos los componentes, y cada uno de los componentes es
reutilizable/esclable. 

Etiquetas vacias en componentes: FRAGMENTOS <> contenido </>
Funcionan como si fueran un <div> pero no tiene propiedades de el y no se muestra cuando se inspecciona. 

CSS EN REACT: Crear carpeta styles dentro de src y dentro de ella agregar los estilos con el nombre del componente deseado. Se importan en el 
componente usando import "../styles/componente.css"

Para anidar multiples componentes en una interfaz se deben utilizar fragmentos en App.js

PROPIEDADES DE COMPONENTES/PROPS: la funcion del componente recibe por parametro las propiedades que pueden modificarse del coponente y las 
recibe desde app.js. Las propiedades pueden ser cualquier tipo de dato.

Hooks: diferencia una pagina de una app web. Crea la apliacion web, le da dinamismo y hace que sea funcional. Funciones de react por defecto 
que dan dinamismo a la aplicacion web (llamada a api, animaciones, etc.). Su notacion es use. Tener en cuenta: useState(), useEffect()
    useState() -> se tiene un estado y un setter de estado. Para declarar estado:
        const[estado,setEstado] = useState("estadoInicial")
        setEstado("segundoEstado")
        Se usan cuando se necesita dinamismo se necesita un estado. La actualizacion del estado es asincrona (no funciona con async Await).
    useEffect() -> es una función cualquiera que se va a ejecutar cada vez que haya un cambio de dependencias. Recibe dos parametros, la
    funcion a ejecutar y las dependecias (opcional) que son ante que situacion se debe ejecutar la función.
        useEffect(funcionAEjecutar, [dependencias])
        useEffect(funcionAEjecutar, []) -> Solo la primera vez 
        useEffect(funcionAEjecutar, [estado1]) -> Cada vez que cambie el estado1 ejecutar la función
        useEffect(funcionAEjecutar, [estado1, estado2]) -> Cada vez que cambie el estado1 o el estado2 ejecutar la función
        Se usan cuando se llama a un GET de una api, debug de un estado, ejecución de eventos, etc. 

IMPORTAR BOOTSTRAP: Ejecutar npm i bootstrap. Agregar en App.js:
    import 'bootstrap/dist/css/bootstrap.min.css';
    import 'bootstrap/dist/js/bootstrap.bundle.min.js';

EN PARCIAL: 
App.js con componente COnsultas que contiene un estado de filas (GET ALL/GET BY FILTER de la API), un filtro (formulario de busqueda) y tabla con registros.
Hacer la lógica. Hacer el GetAll y GetByFilter.

Hacer llamados a API -> npm i axios
AXIOS: Permite consumir una API. Reemplaza el fetch, es decir, que se encarga de hacer el consumo de una API de un tercero. Tiene una sintaxis mas sencilla:
    axios metodo(url, configuraciones)
Las llamadas a la API se realizan dentro de la carpeta "services"
Se debe crear la carpeta "constants" para almacenar la URL de la API a peticionar. 
    Dentro de constants: constant.js con 
                                            export const API URL = "http://localhost:<puerto>/<lo_que_se_repite>/"
                                            Es una variable aparte 
Se debe tener la carpeta routes


ARBOL A OBTENER EN EL PARCIAL (directorios y archivos importantes):
/parcial/
├── backend/                ← API RESTful con Node.js, Express y Sequelize
│   ├── index.js
│   ├── .env
│   ├── package.json
│   ├── base-orm/           ← Inicialización Sequelize
│   │   ├── sequelize-init.js
│   │   └── sqlite-init.js
│   ├── models/             ← Modelos Sequelize
│   ├── routes/             ← Endpoints Express por entidad
│   ├── seguridad/          ← Middleware de autenticación (opcional)
│   └── test/               ← Tests de endpoints (opcional)
│
└── frontend/               ← SPA en React (Create React App o Vite)
    ├── index.html
    ├── vite.config.js      ← Solo si se usa Vite
    ├── package.json
    ├── public/
    └── src/
        ├── main.jsx
        ├── App.jsx
        ├── config.js       ← URL del backend
        ├── components/
        │   ├── Menu.jsx
        │   ├── Footer.jsx
        │   └── Inicio.jsx
        │
        ├── components/[entidad]/
        │   ├── [Entidad].jsx            ← componente principal
        │   ├── [Entidad]Buscar.jsx      ← filtros
        │   ├── [Entidad]Listado.jsx     ← tabla
        │   └── [Entidad]Registro.jsx    ← formulario alta/modificación
        │
        ├── services/
        │   ├── [entidad].service.js     ← peticiones a API
        │   ├── http.service.js          ← wrapper común (axios)
        │   └── modalDialog.service.js   ← alertas / confirmaciones
        │
        └── datos-mock/
            └── [entidad]-mock.js        ← datos simulados (opcional)


PASOS BACKEND: 
1)- npx init -y
2)- npm i axios
3)- Crear carpeta routers con archivo <dominio>.routes.js con los endpoints de usando express


PASOS FRONTEND: 
1)- npx create-react-app frontend
2)- Crear carpeta components:
    -Dentro de la carpeta crear <nombreComponente>.jsx
    -En component.jsx poner: rfc lo que crea la estructura basica del componente. 
3)- Para insertar el componente debemos ir a App.js y dentro de la funcion App() una etiqueta con el nombre del componente
4)- Crear carpeta constants con constants.js que tiene export const API_URL = "http://localhost:<puerto>/<lo_que_se_repite>/"
5)- Crear carpeta service con archivo: <dominio>.service.js donde se va a importar el axios y la constante API_URL. Ademas se deben crear las Funciones
    getAll() y getByFilter(), un objeto <dominio>Services con losm etodos y un export { <dominio>Services }

    ---- GET ALL ----
    OBTENER TODOS LOS DATOS Y LOS RETORNA (EN CASO DE ERROR MOSTRAR EL OBJETO DE ERROR DECLARADO EN ROUTES).
    Esto se utiliza en el componente de consulta, precisamente en el estado, el cual va a almacenar lo que se encuentre en la API.
    const getAll = async () -> {
        try {
            const response = await acios.get(`$(API_URL)/obtenerTodos`);
            console.log(response.data)
            return response.data
        } catch (error) {
            console.log(error.response.data)
            return error.response.data
        }
    }

    En el componente:
    export default function Consulta() {
        const [rows, setRows] = useState([]); 

        return {
            <>
                <div className="row">
                    <Filtro />
                </div>
                <div className="row">
                    <Tabla rows={rows} /> // ACÁ ES DONDE SE PASAN COMO PROPIEDAD LAS FILAS Y SE MUESTRAN
                </div>
            </>
        }
    };
    (Cabe destacar que debe existir un componete tabla llamado function Tabla({rows}))
    Cada fila es un registro de la api.
    Para traer los datos de la api y mostrarlos por pantalla se debe utilizar: 
    (SE DEBE AGREGAR ARRIBA DEL RETURN en Consulta())

    async function fetchData() { // TRAIGO DATOS Y SETEA FILAS
        setRows(await <dominio>services.getAll());
    }

    useEffect(() -> {
        fetchData();
    }, []); // SOLAMENTE LA PRIMERA VEZ QUE SE MUESTRA EL COMPONENTE

    ----- GET BY FILTER ----
    Usar libreria llamada react-hook-form. Instalar con:  npm install react-hook-form 
    REACT HOOK FORM: permite armar formularios sencillamente y de forma personalizada. 
    Debe de existir un componente llamado filtro que use una funcion llamada useForm()
    const Filtro - () -> {
        const {
            register,
            handleSubmit,
            formState: {errors},
            reset,
            setValue,
        } = useForm()
    }

    A cada campo se deben poner sus restricciones, en cada input se debe declarar una serie de reglas. Se debe agregar un objeto {...register()} que recibe
    dos paremetros, el campo a registrar y un objeto de conjunto de reglas. Mas tipicas: required, min, max, minLenght, maxLenght, pattern, validate, etc.
    Cuando se envie el formulario se va a ejecutar una funcion que esta definida onSubmit={handleSubmit(onSubmit)}

    const onSubmit = async (data) -> {
        console.log(data)
    }

    data va a ser un objeto que contenga los valores que salen de los inputs del usuario. Las validaciones son un conjunto de objetos que tiene un required
    y un mensaje. 
    En <dominio>.service.js:
    // data = { nombre: "", apellido: "" }
    const getByFilters = async (data) => {
    try {
        const response = await axios.get(`${API_URL}/byFilters?nombre=${data.nombre}&apellido=${data.apellido}`);
        console.log(response.data);
        return response.data;
    } catch (error) {
        console.log(error.response.data);
        return error.response.data;
    }
    }

    En Consulta.jsx:
    return {
        <div className="row">
            <Filtro setRows={setRows}
    }

    En Filtro.jsx (se debe usar setRows en el filtro para afectar dinamicamente las tablas al aplicar el filtro):
    const onSubmit = async (data) -> {
        console.log(data);
        const response = await <dominio>Services.getByFilters(data);
        setRows(response);
    };

    ---- DELETE ----
    const handleDeleteUser = async (id) => {
        await usuariosServices.deleteUser(id);
        await fetchData(); // Obtener los datos actualizados después de eliminar el usuario
    };

    DEBE DE HABER DOS INTERFACES UNA PARA LA CONSULTA CON getAll, gerByFilter y Delete Y Otra con un formulacio de creacion. Se debe usar la 
    libreria react-router, que sirve para hacer rutas.
    En frontend, en la terminal se instala como: npm i react-router-dom
    Consiste en armar un sistema de navegacion para la pagina. Dividir el formulario de actualizacion en otra pantalla.
    <BrowserRouter> ----> /algo/algo
    <HashRouter> ---> /#/algo/#/algo/ (Hace lo mismo pero con un hashtag)

    <Route/>  Tiene dos propiedades: Path (nombre de la ruta) y element (que pantalla se va a mostrar en esa ruta)

    En App.js, se debe de modificar de la siguiente manera:

    function App() {
        return (
           <BrowserRouter> --- Tipo de navegacion (Dentro de el se debe definir un conjunto de rutas)
            <Routes>
                <Route path="/" element={<ComponenteConsulta />}/> --- RUTA RAIZ: localhost:puerto/ 
                <Route path="/otroComponente" element={<OtroComponente />}/> 
            </Routes>
           </BrowserRouter>
        )
    }

    Se debe crear un componente Menu.jsx que es el menu de opciones de la aplicacion. Permite crear una barra de navegacion responsive. 


    function Menu() {
    return (
        <nav className="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
            <div className="container">
                <Link className="navbar-brand" to="/inicio">Inicio</Link> -- SImilar a la etiqueta a de HTML y te dice a que ruta se va a dirigir
                <div className="navbar-nav">
                    <Link className="nav-link" to="/home">Home</Link>
                    <Link className="nav-link" to="/otro">Otro</Link>
                </div>
            </div>
        </nav>
    );
    }
    export default Menu;
    
    function App() {
        return (
           <BrowserRouter>
           <Menu /> --- Se pone por afuera de las rutas para que aparezca SIEMPRE
            <Routes>
                <Route path="/" element={<ComponenteConsulta />}/> 
                <Route path="/otroComponente" element={<OtroComponente />}/> 
            </Routes>
           </BrowserRouter>
        )
    }

    PAGINAS DE ERROR 404 -----> Cuando no existe la URL. Se debe crear un componente Error.JSX
    Debe tener un encabezado, una imagen si se quiere y un boton para volver a la pagina principal.

        function App() {
        return (
           <BrowserRouter>
           <Menu /> 
            <Routes>
                <Route path="/" element={<ComponenteConsulta />}/> 
                <Route path="/otroComponente" element={<OtroComponente />}/> 
                <Route path="*" element={<Error />}/> 
            </Routes>
           </BrowserRouter>
        )
    }
6)- POSTFORM: Formaulario de creacion (rfc). Para crear este formulario se debe ser consistente con el del menú.

    export default function PostForm() {
        const {register, handleSubmit, formSate: {errors}, reset, setValue} = useForm()
        const onSubmit = async (data) -> { // ES LA QUE LLAMA AL SERVICIO
            console.log(data);
        };
        return (ESTRUCTURA DEL FORMULARIO)
    }

    La estructura del formulario debe tener labels con campos para completar y un boton de crear. Cada campo tiene un label y un input (con sus atributos)
    y un objeto llamado register (envia los datos al objeto data, con reglas required: (value, message) y un maxLenght: (value, message))
    Al enviar el formulario se ejecuta el onSubmit

    Se debe vincula a un servicio de usuarios (DEBE HABER EXTREMA CONSISTENCIA CON EL BACKEND (TENER EN CUENTA Mayusculas y Minusculas)): 
    EN EL SERVICIO:
    const create = async(data) => {
        try {
            const response = await axios.post(`${API_URL}/crearUsuario`, data)
            console.log(response.data)
            return response.data;
        } catch (error) {
            console.log(error.response.data)
            return error.response.data
        }
    }

    EN EL SERVICES DEL BACKEND: 
    const createUser = async(body) = {
        if (!body) {
            throw new Error('Error Faltan datos')
        }

        if (!body.atributo1 || !body.atributo1) {
             throw new Error('Error Faltan datos')
        }
    }

    La idea entonces es:
    1. Ejecucion del servicio
    2. Creacion del registro en Base de datos
    3. Volver a la pantalla inicial si esta todo Ok, sino mostrar error 

    SE DEBE CREAR UN estado
    const [postError, setPostError] = useState(false) -- VA A SER TRUE SI LA API DA ERROR 
     
    const onSubmit = async (data) = {
        console.log(data)
        const.response = await usuariosServices.create(data) 
        console.log("respuesta en post:", response)
        if (response.error) {
            setPostError(response.error); // ACÁ SE CAMBIARIA EL ESTADO
            return
        } 
        navigate("/")
    }


    Dentro del return  (HTML que se retorna), se debe agregar {postErrir && <p>{postError}</p>}
    Se debe utilizar useNavigate para volver a la pantalla principal.

7)- PANTALLA DE ACTUALIZACIÓN: Boton actualizar en la tabla, al lado del borrar en la columna acciones. EL formulario va a variar dinamicamente ya que 
depende de cada usuario. Primero se tendria que definir un formulario de actualizacion PutForm.jsx
    <Route path="/actualizar/:id" element={<PutForm />}/>

En el componente Tabla.jsc debe estar definido el boton de Actualizar, donde (se debe imporar navigate):
    <button onClick=[() -> navigate(`/actualizar/${user.id}`)] classname="btn-..." style={...}> 
    
A nivel maquetacion es igual que el PostForm, lo que cambia es que debemos lograr que  se muestren los datos actuales de cada usuario.
    1.Capturar formulario de acrtualizacion de ese id
    2.Llamar getById para traer datos actuales
    3.Mostrar datos actual en cada uno de los campos
    4.Misma logica de post

    Se debe usar useParams:
    const (id) = useParams()
    console.log("Id capturado: ", id)

Crear getById en servicios:
    const getById = async (id) => {
        try {
            const response = await.axios.get(`${API_URL}/${id}`);
            console.log(response.data)
            return response.data;
        } catch (error) {
            console.log(error.response.data)
            return error.response.data
        }
    }

    Cada vez que se entre a la interfaz (con distintos id). 


// CADA VEZ  QUE SE EJECUTA EL PARAMETRO DE LA URL, SE EJECUTA ESTE EFECTO
useEffect(() => {
    const getUser = async () => {
    const data = await usuariosServices.getById(id);
    // SETEA CADA UNO DE LOS CAMPOS CON LA INFROMACIÓN TRAIDA 
    setValue("nombre", data.nombre);
    setValue("apellido", data.apellido);
    setValue("usuario", data.usuario);
    setValue("password", data.password);
    setValue("email", data.email);
  };
  getUser();
}, [id]);


const onSubmit = async (data, id) => {
  const response = await usuariosServices.upadete(data);
  console.log("respuesta en post: ", response);
  if (response.error) {
    setUpdateError(response.error); // "no se pudo crear el usuario"
    return;
  }
  navigate("/");
};

EN SERVICIO DE ACTUALIZACIOn:
const update = async (data, id) -> {
    try {
        const response = await.axios.put(`${API_URL}/modificar?id=${id}`, data);
        console.log(response.data)
        return response.data;
    } catch (error) {
        console.log(error.response.data)
        return error.response.data
        }
}

EN BACKEND: 
router.put("/modificar", async (req, res) => {
  const { id } = req.query;
  try {
    const response = await usersServices.updateUser(id, req.body);
    return res.json(response);
  } catch (error) {
    return res.status(500).json({ error: error.message });
  }
});

EN SERVICIO DE BACKEND:
const updateUser = async (idUsuario, body) => {
  const userToUpdate = await sequelize.models.Usuarios.findByPk(idUsuario); // busco por clave primaria

  if (!userToUpdate) {
    // si no existe tiro error
    throw new Error("Error, no existe ese usuario");
  }

  // si no viene algún atributo en la solicitud, tiro un error
  if (!body.nombre || !body.apellido || !body.usuario || !body.password || !body.email) {
    throw new Error("Error, falta algún dato");
  }

  // si existe, seteo sus datos como lo que me dio el body
  userToUpdate.nombre = body.nombre;
  userToUpdate.apellido = body.apellido;
  userToUpdate.usuario = body.usuario;
  userToUpdate.password = body.password;
  userToUpdate.email = body.email;

  await userToUpdate.save(); // no olvidarse de guardar los cambios

  return userToUpdate;
};

El camino que hace entonces es:
-Se ingresan los datos en el PutForm
-PutForm llama al servicio update
-Cuando llama al servicio, en el router del backend llama al servicio para que actualice el usuario
-El servicio del backend determina si existe o no un error.
-Si existe muestra un error, si no existe actualiza el registro en la bd. 

PARA PARCIAL!!!
Codigos de respuesta HTTP:
200 -> Todo Ok
200 -> OK
201 -> Creado

400 -> Errores de usuario
400 -> Faltan datos
404 -> No encontrado
401 -> No autorizado

500 -> Errores de servidor/programa
500 -> Error imprevisto


1)- Backend:npm init -y 
            npm install express sequelize sqlite3 cors
            npm install --save-dev nodemon
            npm i

    Frontend: npm create vite@latest frontend -- --template react
              npm install
              npm install axios react-router-dom
              npm i
              npm install react-hook-form

BACKEND: 
1) - Crear proyecto Node.js: Dentro de backend/, ya está inicializado con npm init y tiene sus dependencias: express, sequelize, sqlite3, cors.
2) - Estructura base: Dentro de src/ están las subcarpetas necesarias:
    components/: modelo Sequelize de la entidad principal (por ejemplo, Articulo.js, Reserva.js, etc.)
    routes/: define los endpoints de Express
    services/: encapsula la lógica CRUD
    database/: contiene database.js con la conexión a SQLite
    index.js: punto de entrada principal del servidor
3) - Definir modelo Sequelize: Crear el archivo correspondiente en components/ con los atributos especificados por la consigna (ejemplo: Reserva.js)
4) - Configurar Sequelize: En database/database.js se importa Sequelize y se crea la instancia usando SQLite, apuntando al archivo .db.
5) - Crear servicio CRUD: En services/, se define el archivo que hace create, findAll, findByPk, update, y destroy sobre el modelo.
6) - Configurar rutas Express: En routes/, definir los endpoints RESTful (GET /, POST /, PUT /:id, DELETE /:id, GET /:id).
7) - Levantar servidor: En index.js se importa todo, se aplican middlewares (cors, express.json()), se montan rutas, y se hace sync() con Sequelize.
8) - Probar API: Usar Postman para validar que todos los endpoints funcionan correctamente.


FRONTEND:
1) - Crear proyecto con Vite: generar el proyecto con 'npm create vite@latest frontend --template react'
2) - Instalar dependencias necesarias: como axios y react-router-dom.
3) - Agregar Bootstrap 5: En index.html del public/, se incluye Bootstrap por CDN.
4) - Estructurar componentes en src/components/: Componentes funcionales como: Tabla, Formulario, Filtro, etc.
5) - Servicios Axios: En src/services/, hay archivos como articulos.service.js, que definen funciones como getAll, getById, create, update, delete.
6) - Router y navegación SPA: En App.jsx, se usa <BrowserRouter> y <Routes> para definir rutas únicas. Todo se muestra en una sola página.
7) - Control de estado: App.jsx o el componente principal controla el estado general (useState, useEffect) y renderiza según el modo: listado, alta, modificación, etc.
8) - Formulario de carga y edición: Un mismo formulario sirve para alta y modificación. Se muestra u oculta según el estado actual (AccionABMC).
9) - Tabla de resultados y búsqueda: Se renderiza la tabla al cargar. Permite filtrar resultados por búsqueda textual (case-insensitive).
10) - Conexión con el backend: Cada acción en el frontend llama a los métodos definidos con Axios que interactúan con los endpoints del backend.